/**
 * @file    LightSchedulerRandomizeTest.cpp
 * @author  Julio Cesar Bernal Mendez
 * @brief   Light Scheduler Randomize test source file
 * 
 * @version 0.1
 * @date    2025-04-14
 */

extern "C"
{
    /* includes for things with C linkage */
    #include "FakeRandomMinute.h"
    #include "LightScheduler.h"
    #include "FakeTimeService.h"
    #include "LightControllerSpy.h"
}

/* includes for things with C++ linkage */
#include "TestHarness.h"

TEST_GROUP( LightSchedulerRandomize )
{
    /* define data accessible to test group members here */
      
    void setup()
    {
        /* initialization steps are executed before each TEST */
        LightController_Create();
        LightScheduler_Create();

        /* Function pointer restoration is so common that CppUTest has a built-in macro for setting
           and restoring function pointers.
           
           When a function pointer is set with UT_PTR_SET() duging setup() or during any TEST(),
           it's automatically restored after teardown() completes */

        /* update RandomMinute_Get to point to the fake Random Minute generator (this is done to have control on
           the values returned by RandomMinute_Get in the tests) */
        UT_PTR_SET( RandomMinute_Get, FakeRandomMinute_Get );
    }
      
    void teardown()
    {
        /* clean up steps are executed after each TEST */
    }

    /* Repeated operations and checks can be extracted into helper functions,
       leaving the tests easier to read */
    void setTimeTo( int day, int minuteOfDay )
    {
        /* The test takes control of the clock, telling the Fake Time Source (Fake Time Service) that it
           should report that it's "day" at "minuteOfDay" */
        FakeTimeService_SetDay( day );
        FakeTimeService_SetMinute( minuteOfDay );
    }

    /* Repeated operations and checks can be extracted into helper functions,
       leaving the tests easier to read */
    void checkLightState( int id, int state )
    {
        /* This test helper now is modified to use LightControllerSpy_GetLightState(),
           this change allows checkLightState() to work in the multiple event case */

        /* the test checks the expected outcome (the time for the scheduled light ID has been reached,
           then light ID should be "id" and state should be "state") */
        if ( id == LIGHT_ID_UNKNOWN )
        {
            LONGS_EQUAL( id, LightControllerSpy_GetLastId() );
            LONGS_EQUAL( state, LightControllerSpy_GetLastState() );
        }
        else
        {
            LONGS_EQUAL( state, LightControllerSpy_GetLightState( id ) );
        }
    }
};
   
TEST( LightSchedulerRandomize, TurnsOnEarly )
{
    /* Establish a not so random sequence for the fake RandomMinute_Get(),
       with -10 the first "random" value to be generated,
       -5 the second "random" value to be generated,
       0 the third "random" value to be generated,
       5 the fourth "random" value to be generated,
       and so on... */
    FakeRandomMinute_SetFirstAndIncrement( -10, 5 );

    /* Schedule light ID 4 to turn on everyday at minute 600 (10am).
       Randomization of the scheduled event is disabled by default */
    LightScheduler_ScheduleTurnOn( 4, EVERYDAY, 600 );

    /* Enable randomization of the next scheduled event:
       - light ID 4
       - scheduled everyday
       - at 10am
       
       If the event exists (which it does), then Randomization of that scheduleed event will be enabled.
       What Randomization does in production is, it gets a random minute between -30 and +30 to the
       scheduled event minute of the day, so that the light will turn on/off at 10am with an offset of -30 to +30 minutes.

       In this case since we are using a fake random minute generator (RandomMinute_Get function pointer points to the fake double),
       then we have control over the values returned by RandomMinute_Get() thanks to FakeRandomMinute_SetFirstAndIncrement() */
    LightScheduler_Randomize( 4, EVERYDAY, 600 );

    /* Set 600 - 10 (9:50 am) as the current minute of the day and Monday as the current day of the week.
       -10 is the start random minute to be generated by the fake RandomMinute_Get(), was set by FakeRandomMinute_SetFirstAndIncrement(),
        and the random minute was generetad by a call to RandomMinute_Get() which points to Fake_RandomMinute_Get().
        
        FakeRandomMinute_Get() was called inside LightScheduler_Randomize().
        
        In summary: the not so random minute -10 was obtained by randomizing the event by LightScheduler_Randomize() */
    setTimeTo( MONDAY, 600 - 10 );

    /* The test simulates a callback to LightScheduler_WakeUp(), like the production TimeService
       would do every minute */
    LightScheduler_WakeUp();

    /* Finally the test checks the expected outcome.
    
       The time for the scheduled light ID has been reached (everyday at minute 600 - "random minute", i.e. 600 - 10)
       then light ID should be 4 and state should be ON */
    checkLightState( 4, LIGHT_ON );
}
